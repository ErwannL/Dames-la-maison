<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de Dames</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 100%;
            position: relative;
        }

        /* Header layout */
    .app-header { display:flex;flex-direction:column; gap:10px; margin-bottom:14px }
    .header-top { display:flex;align-items:center;justify-content:space-between }
    .header-bottom { display:flex;justify-content:center }
    .title-left h1 { margin:0;font-size:1.4rem;color:#111; }
    .header-bottom .controls { display:flex;gap:10px }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }

        .btn-pvp {
            background: #4CAF50;
            color: white;
        }

        .btn-bot {
            background: #2196F3;
            color: white;
        }

        .btn-reset {
            background: #f44336;
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 8px;
            background: #f0f0f0;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            aspect-ratio: 1;
            border: 4px solid #333;
            border-radius: 8px;
            overflow: hidden;
            margin: 0 auto;
            max-width: 500px;
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square.selected {
            background: #7fc97f !important;
        }

        .square.valid-move {
            background: #90ee90 !important;
        }

        .square.must-capture {
            /* Indicator for mandatory-capture squares (subtle outline) */
            box-shadow: inset 0 0 0 4px rgba(255, 0, 0, 0.06);
        }

        .blown-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            animation: blownMessageAnim 4s ease-in-out;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        @keyframes blownMessageAnim {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            10% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            85% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
        }

        @keyframes pulse {
            0%, 100% { background: #ffcccc !important; }
            50% { background: #ff9999 !important; }
        }

        @keyframes blowAway {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.5) rotate(180deg); opacity: 0.5; }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }

        .piece {
            width: 70%;
            height: 70%;
            border-radius: 50%;
            border: 3px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #c92a2a);
            color: white;
        }

        .piece.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #1a1a1a);
            color: white;
        }

        .piece:hover {
            transform: scale(1.1);
        }

        .piece.blown-away {
            animation: blowAway 1s ease-out forwards;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.5em;
            }

            button {
                padding: 10px 15px;
                font-size: 14px;
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="app-header">
        <div class="header-top">
            <div class="title-left">
                <h1>üéØ Jeu de Dames</h1>
            </div>
            <div class="header-gear">
                <button id="btn-settings" class="settings-gear" title="Param√®tres" aria-label="Param√®tres">‚öôÔ∏è</button>
            </div>
        </div>
        <div class="header-bottom">
            <div class="controls">
                <button class="btn-pvp" id="btn-play-together">Jouer √† deux</button>
                <button class="btn-bot" id="btn-play-solo">Jouer contre le robot Erwann</button>
                <button class="btn-reset" id="btn-reset" onclick="resetGame()">R√©initialiser</button>
            </div>
        </div>
    </div>
    <div class="status" id="status">S√©lectionnez un mode de jeu</div>
    <div class="board" id="board"></div>
</div>

<!-- Modal for choosing who starts / who plays -->
<div id="choiceModal" class="modal" style="display:none;">
    <div class="modal-content">
        <h2 id="modalTitle">Qui commence ?</h2>
        <div class="modal-buttons">
            <button id="choosePapy" class="btn-modal">Papy (Rouge)</button>
            <button id="chooseMamie" class="btn-modal">Mamie (Noir)</button>
        </div>
    </div>
</div>

<!-- Settings modal -->
<div id="settingsModal" class="modal" style="display:none;">
    <div class="modal-content settings-content">
        <div class="settings-header">
                <h2 class="settings-title">Param√®tres</h2>
            </div>
        <div class="settings-body">
            <div class="settings-row">
                <label class="settings-label">Autoriser mouvement arri√®re (pour pions)</label>
                <input type="checkbox" id="settings-backward" />
            </div>
            <div class="settings-row">
                <label class="settings-label">Activer r√®gle "Souffler n'est pas jouer"</label>
                <input type="checkbox" id="settings-souffler" checked />
            </div>
            <div class="settings-row">
                <label class="settings-label">Prioriser capture par la dame</label>
                <input type="checkbox" id="settings-prioritize-queen" />
            </div>
            <div class="settings-row">
                <label class="settings-label">Niveau du Robot</label>
                <div>
                    <select id="settings-bot-level" class="settings-select">
                        <option value="easy">facile (al√©atoire)</option>
                        <option value="medium" selected>normal (strat√©gique)</option>
                        <option value="hard">difficile (implacable)</option>
                    </select>
                </div>
            </div>
                <!-- Bot think time (only shown when Hard difficulty is selected) -->
                <div class="settings-row" id="settings-bot-think-row" style="display:none;">
                    <div style="display:flex;flex-direction:column;gap:8px;max-width:78%;">
                        <div class="settings-label">Temps de r√©flexion du Robot (Hard)</div>
                    </div>
                    <select id="settings-bot-think" class="settings-select">
                        <option value="1000">1 seconde</option>
                        <option value="2000">2 secondes</option>
                        <option value="3000">3 secondes</option>
                        <option value="5000">5 secondes</option>
                        <option value="10000">10 secondes</option>
                        <option value="15000">15 secondes</option>
                        <option value="20000">20 secondes</option>
                        <option value="30000">30 secondes</option>
                        <option value="max">Max (limite s√©curit√©)</option>
                    </select>
                </div>
                <div id="settings-bot-warning" class="settings-warning" style="display:none;">‚ö†Ô∏è Temps de r√©flexion &gt; 10 s ‚Äî cela peut rendre l'interface moins r√©active.</div>
        </div>
        <div class="settings-actions">
            <button id="settings-save" class="btn-modal">Enregistrer</button>
            <button id="settings-cancel-2" class="btn-modal">Annuler</button>
        </div>
    </div>
</div>

<style>
    /* Modal styles */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }

    .modal-content {
        background: white;
        padding: 24px;
        border-radius: 12px;
        text-align: center;
        max-width: 320px;
        width: 90%;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    /* Settings modal overrides */
    .settings-content {
        max-width: 460px;
        width: 92%;
        background: #ffffff;
        border-radius: 12px;
        padding: 20px 22px;
        box-shadow: 0 18px 50px rgba(15,20,25,0.12);
        text-align: left;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .settings-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:12px; }
    .settings-header h2 { margin:0; font-size:18px; color:#0f1724 }
    .settings-body { display:flex;flex-direction:column; gap:14px; margin-top:4px; }
    .settings-row { display:flex;justify-content:space-between;align-items:center; }
    .settings-label { font-size:15px;color:#0f1724; max-width:78%; }
    .settings-select { padding:8px 10px;border-radius:8px;border:1px solid #e6e9ee; background:#fff }
    .settings-warning { color: #92400e; background: #fff7ed; border: 1px solid #ffedd5; padding: 8px 10px; border-radius: 6px; font-size:13px; margin-top:8px }
    .settings-actions { display:flex;justify-content:flex-end;gap:10px;margin-top:16px }

    /* Gear button placed inline in header */
    .header-gear { display:flex; align-items:center; }
    .settings-gear { width:40px; height:40px; border-radius:8px; display:flex;align-items:center;justify-content:center; background:#fff;border:1px solid #eef2f6; cursor:pointer; font-size:16px }
    .settings-gear:hover { box-shadow:0 8px 18px rgba(16,24,40,0.06); transform: translateY(-2px); }

    /* Ultra-clean modal adjustments */
    .settings-content { background:#FF7FD1; border:1px solid #FF7A00 }
    .settings-label { color:#000 }
    .settings-select { border:1px solid #ffddee; background: #fff }
    .btn-modal { border-radius:8px;padding:8px 12px;border:none;cursor:pointer }
    .btn-modal[style] { box-shadow:none }
    .btn-modal:hover { opacity:0.95 }
    /* Close cross removed - styling for removed element cleared */
    /* Cancel action button remains orange with white text */
    #settings-cancel-2 { background:#FF7A00;border:none;color:white }
    #settings-save { background:#7c4dff;color:white }

    /* removed accent bar */
    .settings-x { position:absolute; right:14px; top:8px; background:transparent;border:none;font-size:18px;color:#FF7A00; width:30px; height:30px; display:flex;align-items:center;justify-content:center; z-index:5 }
    .settings-header { position:relative; display:flex;align-items:center;justify-content:center;margin-bottom:8px }
    .settings-header h2, .settings-header .settings-title { color:#000;margin:0;padding:0;text-align:center }

    .modal-buttons {
        display: flex;
        gap: 12px;
        margin-top: 16px;
        justify-content: center;
    }

    .btn-modal {
    padding: 10px 14px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-weight: bold;
    min-width: 110px;
    }

    #choosePapy { background: #4CAF50; color: white; }
    #chooseMamie { background: #2196F3; color: white; }
    /* last-move highlight styles */
    </style>

    <style>
          /* Color-specific last-move highlights to match player color
              - "from" = pastel (lighter)
              - "to"   = darker (stronger)
          */
          /* Red player: pastel pink for previous, deeper red for destination */
          .square.last-from-red { background: linear-gradient(0deg, rgba(255, 235, 238, 0.85), rgba(255, 235, 238, 0.85)) !important; box-shadow: inset 0 0 0 2px rgba(255, 179, 186, 0.45) !important; }
          .square.last-to-red { background: linear-gradient(0deg, rgba(255, 115, 115, 0.18), rgba(255, 80, 80, 0.18)) !important; box-shadow: inset 0 0 0 4px rgba(200,30,30,0.72) !important; }
          .square.last-to-red .piece { transform: scale(1.04); }

          /* Black player: pastel gray for previous, stronger dark outline for destination */
          .square.last-from-black { background: linear-gradient(0deg, rgba(245,245,245,0.85), rgba(245,245,245,0.85)) !important; box-shadow: inset 0 0 0 2px rgba(200,200,200,0.45) !important; }
          .square.last-to-black { background: linear-gradient(0deg, rgba(80,80,80,0.12), rgba(80,80,80,0.12)) !important; box-shadow: inset 0 0 0 4px rgba(40,40,40,0.85) !important; }
          .square.last-to-black .piece { transform: scale(1.04); filter: drop-shadow(0 0 6px rgba(0,0,0,0.35)); }

          /* Fallback subtle highlight if color is not set */
          .square.last-from { box-shadow: inset 0 0 0 3px rgba(255,215,0,0.16); }
          .square.last-to { box-shadow: inset 0 0 0 4px rgba(255,215,0,0.24); }

        @keyframes lastMovePulse { 0%{transform:scale(1)}50%{transform:scale(1.02)}100%{transform:scale(1)} }
        .square.last-to .piece { animation: lastMovePulse 700ms ease; }
    </style>

    <script>
    const ROWS = 8;
    const COLS = 8;
    let board = [];
    let selectedPiece = null;
    let currentPlayer = 'red';
    let gameMode = null;
    let validMoves = [];
    let mustCapture = false;
    let continuousCapture = false;
    let piecesThatCouldCapture = [];
    // Configuration flags controll√©es par l'UI
    const CONFIG = {
        allowBackwardMoves: false,
        enableSoufflerRule: true
        ,botLevel: 'medium' // 'easy' | 'medium' | 'hard'
        ,prioritizeQueenCapture: false // when true, prefer captures done by queens; penalize pawn capture when queen could
        ,botThinkTime: '20000' // default think time for hard bot (ms as string). Options: '1000','2000','3000','5000','10000','15000','20000','30000','max'
    };

    // --- Persistence helpers (uses DOM storage / localStorage inside WebView) ---
    function saveSettingsToStorage() {
        try {
            localStorage.setItem('dames_settings', JSON.stringify(CONFIG));
            console.log('Saved settings to localStorage');
        } catch (e) {
            console.warn('Failed to save settings', e);
        }
    }

    function loadSettingsFromStorage() {
        try {
            const s = localStorage.getItem('dames_settings');
            if (s) {
                const parsed = JSON.parse(s);
                // Merge saved values into CONFIG (only keys present will be replaced)
                Object.assign(CONFIG, parsed);
                console.log('Loaded settings from localStorage', parsed);
            }
        } catch (e) {
            console.warn('Failed to load settings', e);
        }
    }

    // --- Zobrist hashing for transposition cache (faster and smaller keys than JSON stringify)
    const ZOBRIST = {
        table: null,
        sideRandom: 0,
        init() {
            // piece types: 0 empty, 1 red man, 2 red king, 3 black man, 4 black king
            this.table = [];
            for (let r = 0; r < ROWS; r++) {
                this.table[r] = [];
                for (let c = 0; c < COLS; c++) {
                    this.table[r][c] = [];
                    for (let k = 0; k < 5; k++) {
                        this.table[r][c][k] = this.random32();
                    }
                }
            }
            this.sideRandom = this.random32();
        },
        random32() {
            // return a 32-bit unsigned integer
            return Math.floor(Math.random() * 0x100000000) >>> 0;
        },
        computeKey(b) {
            let h = 0 >>> 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const p = b[r][c];
                    if (!p) continue;
                    let idx = 0;
                    if (p.color === 'red') idx = p.isKing ? 2 : 1;
                    else idx = p.isKing ? 4 : 3;
                    h = (h ^ this.table[r][c][idx]) >>> 0;
                }
            }
            return h;
        }
    };
    ZOBRIST.init();
    
        // Security cap for the 'max' option (ms). When user selects 'max' the engine may think up
        // to this many milliseconds to avoid locking the browser indefinitely.
        const MAX_BOT_THINK_MS = 120000; // 2 minutes
    // Persisted choice: who is the human when playing vs bot or who starts when playing together
    let persistedHumanColor = 'red'; // 'red' or 'black' - default red
    let persistedStarter = undefined; // 'red' or 'black' - who started last (persist across resets)
    let timeouts = [];
    let lastMove = null; // { fromRow, fromCol, toRow, toCol } - used to highlight the last moved piece

    function initBoard() {
        board = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));

        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < COLS; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { color: 'black', isKing: false };
                }
            }
        }

        for (let row = 5; row < 8; row++) {
            for (let col = 0; col < COLS; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { color: 'red', isKing: false };
                }
            }
        }
    }

    function renderBoard() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';

        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const square = document.createElement('div');
                square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                // highlight last moved squares (from / to) and attach a color-specific class
                if (lastMove) {
                    if (lastMove.fromRow === row && lastMove.fromCol === col) {
                        square.classList.add('last-from');
                        if (lastMove.color) square.classList.add('last-from-' + lastMove.color);
                    }
                    if (lastMove.toRow === row && lastMove.toCol === col) {
                        square.classList.add('last-to');
                        if (lastMove.color) square.classList.add('last-to-' + lastMove.color);
                    }
                }
                square.dataset.row = row;
                square.dataset.col = col;

                if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                    square.classList.add('selected');
                }

                if (validMoves.some(m => m.row === row && m.col === col)) {
                    square.classList.add('valid-move');
                }

                const piece = board[row][col];
                if (piece) {
                    const pieceEl = document.createElement('div');
                    pieceEl.className = `piece ${piece.color}`;
                    if (piece.isKing) {
                        pieceEl.textContent = '‚ôî';
                    }
                    square.appendChild(pieceEl);
                }

                square.addEventListener('click', () => handleSquareClick(row, col));
                boardEl.appendChild(square);
            }
        }
    }

    function handleSquareClick(row, col) {
        if (!gameMode) return;
        // If playing vs bot, ignore clicks when it's not the human's turn
        if (gameMode === 'bot') {
            const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
            if (currentPlayer === botColor) return;
        }

        const piece = board[row][col];

        console.log(`=== CLICK sur (${row}, ${col}) ===`);
        console.log(`Joueur actuel: ${currentPlayer}`);
        console.log(`Pi√®ce cliqu√©e:`, piece);
        console.log(`Continuous capture: ${continuousCapture}`);

        // Si on est en mode capture continue, on v√©rifie d'abord si on clique sur un mouvement de capture
        if (continuousCapture && selectedPiece) {
            console.log('-> Mode capture continue actif');
            const move = validMoves.find(m => m.row === row && m.col === col);
            if (move && move.isCapture) {
                console.log('-> Capture continue d√©tect√©e');
                makeMove(selectedPiece.row, selectedPiece.col, row, col);
                return;
            } else {
                console.log('-> Mouvement non valide en capture continue, d√©s√©lection');
                selectedPiece = null;
                validMoves = [];
                continuousCapture = false;
                renderBoard();
                return;
            }
        }

        if (selectedPiece) {
            console.log(`Pi√®ce d√©j√† s√©lectionn√©e: (${selectedPiece.row}, ${selectedPiece.col})`);
            const move = validMoves.find(m => m.row === row && m.col === col);
            if (move) {
                console.log('-> Mouvement valide trouv√©:', move);
                makeMove(selectedPiece.row, selectedPiece.col, row, col);
            } else if (piece && piece.color === currentPlayer) {
                console.log('-> Nouvelle pi√®ce s√©lectionn√©e');
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                console.log('-> Mouvements valides:', validMoves);
            } else {
                console.log('-> D√©s√©lection');
                selectedPiece = null;
                validMoves = [];
            }
        } else if (piece && piece.color === currentPlayer) {
            console.log('-> Premi√®re s√©lection de pi√®ce');
            selectedPiece = { row, col };
            validMoves = getValidMoves(row, col);
            console.log('-> Mouvements valides:', validMoves);
        }

        renderBoard();
    }

    function getValidMoves(row, col) {
        const piece = board[row][col];
        if (!piece) return [];

        const moves = [];
        const captures = [];

        if (piece.isKing) {
            const directions = [[-1,-1], [-1,1], [1,-1], [1,1]];
            for (const [dr, dc] of directions) {
                for (let dist = 1; dist < ROWS; dist++) {
                    const newRow = row + dr * dist;
                    const newCol = col + dc * dist;

                    if (newRow < 0 || newRow >= ROWS || newCol < 0 || newCol >= COLS) break;

                    if (!board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol, isCapture: false });
                    } else if (board[newRow][newCol].color !== piece.color) {
                        for (let jumpDist = 1; jumpDist < ROWS; jumpDist++) {
                            const jumpRow = newRow + dr * jumpDist;
                            const jumpCol = newCol + dc * jumpDist;

                            if (jumpRow < 0 || jumpRow >= ROWS || jumpCol < 0 || jumpCol >= COLS) break;

                            if (!board[jumpRow][jumpCol]) {
                                captures.push({
                                    row: jumpRow,
                                    col: jumpCol,
                                    capturedRow: newRow,
                                    capturedCol: newCol,
                                    isCapture: true
                                });
                            } else {
                                break;
                            }
                        }
                        break;
                    } else {
                        break;
                    }
                }
            }
        } else {
            // For normal pieces, allow forward simple moves by default. If CONFIG.allowBackwardMoves is true,
            // allow the opposite simple moves as well. However, captures (eating) are allowed in all
            // diagonal directions for normal pieces regardless of CONFIG.allowBackwardMoves.
            let moveDirections = piece.color === 'red' ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]];
            if (CONFIG.allowBackwardMoves) {
                moveDirections = [[-1,-1], [-1,1], [1,-1], [1,1]];
            }

            // captureDirections always allow captures in both forward and backward diagonals
            const captureDirections = [[-1,-1], [-1,1], [1,-1], [1,1]];

            // simple (non-capture) moves
            for (const [dr, dc] of moveDirections) {
                const newRow = row + dr;
                const newCol = col + dc;

                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                    if (!board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol, isCapture: false });
                    }
                }
            }

            // captures (always allow both directions)
            for (const [dr, dc] of captureDirections) {
                const newRow = row + dr;
                const newCol = col + dc;

                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                    if (board[newRow][newCol] && board[newRow][newCol].color !== piece.color) {
                        const jumpRow = newRow + dr;
                        const jumpCol = newCol + dc;
                        if (jumpRow >= 0 && jumpRow < ROWS && jumpCol >= 0 && jumpCol < COLS && !board[jumpRow][jumpCol]) {
                            captures.push({
                                row: jumpRow,
                                col: jumpCol,
                                capturedRow: newRow,
                                capturedCol: newCol,
                                isCapture: true
                            });
                        }
                    }
                }
            }
        }

        if (captures.length > 0) {
            const maxCaptures = findMaxCaptures(row, col, piece);
            return maxCaptures;
        }

        return moves;
    }

    function findMaxCaptures(row, col, piece, captured = [], depth = 0) {
        const captureMoves = [];
        const directions = piece.isKing ?
            [[-1,-1], [-1,1], [1,-1], [1,1]] :
            (CONFIG.allowBackwardMoves ? [[-1,-1], [-1,1], [1,-1], [1,1]] : (piece.color === 'red' ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]]));

            if (piece.isKing) {
                // For kings, we scan along each diagonal to find an enemy and possible landing squares after it.
                for (const [dr, dc] of directions) {
                    for (let dist = 1; dist < ROWS; dist++) {
                        const enemyRow = row + dr * dist;
                        const enemyCol = col + dc * dist;

                        if (enemyRow < 0 || enemyRow >= ROWS || enemyCol < 0 || enemyCol >= COLS) break;

                        if (board[enemyRow][enemyCol]) {
                            if (board[enemyRow][enemyCol].color !== piece.color &&
                                !captured.some(c => c.row === enemyRow && c.col === enemyCol)) {
                                // After the enemy, king may land any empty square beyond it along same direction
                                for (let jumpDist = 1; jumpDist < ROWS; jumpDist++) {
                                    const jumpRow = enemyRow + dr * jumpDist;
                                    const jumpCol = enemyCol + dc * jumpDist;

                                    if (jumpRow < 0 || jumpRow >= ROWS || jumpCol < 0 || jumpCol >= COLS) break;

                                    if (!board[jumpRow][jumpCol]) {
                                        captureMoves.push({
                                            row: jumpRow,
                                            col: jumpCol,
                                            capturedRow: enemyRow,
                                            capturedCol: enemyCol,
                                            isCapture: true,
                                            captureCount: captured.length + 1
                                        });
                                    } else if (board[jumpRow][jumpCol]) {
                                        // blocked beyond enemy
                                        break;
                                    }
                                }
                            }
                            break; // whether enemy or ally, stop scanning further in this direction
                        }
                    }
                }
            } else {
                // For non-king pieces: allow captures in all diagonal directions regardless of CONFIG.allowBackwardMoves.
                const captureDirections = [[-1,-1], [-1,1], [1,-1], [1,1]];
                for (const [dr, dc] of captureDirections) {
                    const enemyRow = row + dr;
                    const enemyCol = col + dc;

                    if (enemyRow >= 0 && enemyRow < ROWS && enemyCol >= 0 && enemyCol < COLS) {
                        if (board[enemyRow][enemyCol] &&
                            board[enemyRow][enemyCol].color !== piece.color &&
                            !captured.some(c => c.row === enemyRow && c.col === enemyCol)) {
                            const jumpRow = enemyRow + dr;
                            const jumpCol = enemyCol + dc;
                            if (jumpRow >= 0 && jumpRow < ROWS && jumpCol >= 0 && jumpCol < COLS && !board[jumpRow][jumpCol]) {
                                captureMoves.push({
                                    row: jumpRow,
                                    col: jumpCol,
                                    capturedRow: enemyRow,
                                    capturedCol: enemyCol,
                                    isCapture: true,
                                    captureCount: captured.length + 1
                                });
                            }
                        }
                    }
                }
            }

        if (captureMoves.length === 0) {
            return depth === 0 ? [] : captured;
        }

        return captureMoves;
    }

    function makeMove(fromRow, fromCol, toRow, toCol) {
        console.log(`\n=== MAKE MOVE de (${fromRow},${fromCol}) vers (${toRow},${toCol}) ===`);
        const piece = board[fromRow][fromCol];

        let wasCapture = false;
        // Determine if this move actually captures a piece by checking squares between from and to.
        const dr = Math.sign(toRow - fromRow);
        const dc = Math.sign(toCol - fromCol);
        let capturedSquare = null;
        // If prioritizeQueenCapture is enabled, detect if a queen of the mover could capture
        // the same target. We record it here before the board is modified so we can apply
        // a penalty later if the player chooses a pawn capture instead of a queen.
        let queenCandidate = null;
        if (Math.abs(toRow - fromRow) >= 2 || Math.abs(toCol - fromCol) >= 2) {
            // scan along the path for an enemy piece
            for (let step = 1; step < Math.max(Math.abs(toRow - fromRow), Math.abs(toCol - fromCol)); step++) {
                const r = fromRow + dr * step;
                const c = fromCol + dc * step;
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS) break;
                if (board[r][c]) {
                    if (board[r][c].color !== piece.color) {
                        capturedSquare = { row: r, col: c };
                        wasCapture = true;
                        console.log(`-> C'est une CAPTURE de la pi√®ce en (${r}, ${c})`);
                        // locate a queen of the mover's color that could capture that same piece
                        if (CONFIG.prioritizeQueenCapture) {
                            for (let qr = 0; qr < ROWS; qr++) {
                                for (let qc = 0; qc < COLS; qc++) {
                                    const p = board[qr][qc];
                                    if (p && p.color === piece.color && p.isKing) {
                                        const kmoves = getValidMoves(qr, qc);
                                        if (kmoves.some(m => m.isCapture && m.capturedRow === r && m.capturedCol === c)) {
                                            queenCandidate = { row: qr, col: qc };
                                            qr = ROWS; // break outer
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    } else {
                        // blocked by own piece
                        break;
                    }
                }
            }
        } else {
            console.log("-> C'est un mouvement NORMAL");
        }

    // D√©placer la pi√®ce
    board[toRow][toCol] = piece;
    board[fromRow][fromCol] = null;
    // record last move for UI highlighting (include piece color so CSS can use matching highlight)
    lastMove = { fromRow, fromCol, toRow, toCol, color: piece.color };

        if (wasCapture && capturedSquare) {
            const cr = capturedSquare.row;
            const cc = capturedSquare.col;
            console.log(`-> Capture confirm√©e de la pi√®ce en (${cr}, ${cc})`);
            blowAwayPiece(cr, cc);
            board[cr][cc] = null;
            // If priority rule is enabled and the mover was a pawn while a queen could have
            // captured the same piece, apply the penalty: downgrade that queen to a pawn
            // and show an alert to the player.
            if (CONFIG.prioritizeQueenCapture && queenCandidate && !piece.isKing) {
                // show penalty popup now, but apply the downgrade after popup fade + 1s delay
                showQueenPenaltyMessage();
                // capture the queen position now (in case board changes elsewhere)
                const qPos = { row: queenCandidate.row, col: queenCandidate.col };
                const tPenalty = setTimeout(() => {
                    const q = board[qPos.row] && board[qPos.row][qPos.col];
                    if (q && q.isKing) {
                        q.isKing = false;
                        console.log(`-> P√©nalit√© appliqu√©e : la dame en (${qPos.row}, ${qPos.col}) est r√©trograd√©e en pion.`);
                        // reflect change now
                        renderBoard();
                    }
                }, 6000); // 4s visible +1s fade +1s delay before showing penalty
                timeouts.push(tPenalty);
            }
        }

        // Promotion en dame
        if ((piece.color === 'red' && toRow === 0) || (piece.color === 'black' && toRow === 7)) {
            piece.isKing = true;
            console.log('-> Promotion en DAME !');
        }

        // V√©rifier les captures multiples
        if (wasCapture) {
            const nextCaptures = getValidMoves(toRow, toCol).filter(m => m.isCapture);

            if (nextCaptures.length > 0) {
                console.log('-> CAPTURES MULTIPLES possibles:', nextCaptures);
                selectedPiece = { row: toRow, col: toCol };
                validMoves = nextCaptures;
                continuousCapture = true;
                updateStatus(piece.color === 'red' ? "Prise multiple ! Continuez..." : "Le robot continue...");
                renderBoard();

                if (gameMode === 'bot') {
                    const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
                    if (currentPlayer === botColor) {
                        const t = setTimeout(botMove, 700);
                        timeouts.push(t);
                    }
                }
                return; // On reste sur le m√™me tour pour la capture suivante
            }
        }

        // Si pas de capture multiple, on termine le tour
        selectedPiece = null;
        validMoves = [];
        continuousCapture = false;

        console.log(`\n--- V√âRIFICATION R√àGLE SOUFFLER ---`);
        console.log(`wasCapture: ${wasCapture}`);
        console.log(`piecesThatCouldCapture:`, piecesThatCouldCapture);

        // Appliquer la r√®gle souffler si activ√©e et si le joueur n'a pas fait de capture alors qu'il pouvait
        if (CONFIG.enableSoufflerRule && !wasCapture && piecesThatCouldCapture.length > 0) {
            console.log('üå¨Ô∏è APPLICATION DE LA R√àGLE SOUFFLER !');

            // Choisir une pi√®ce au hasard parmi celles qui pouvaient capturer
            const randomIndex = Math.floor(Math.random() * piecesThatCouldCapture.length);
            const pieceToBlow = piecesThatCouldCapture[randomIndex];

            console.log(`-> Pion √† souffler: (${pieceToBlow.row}, ${pieceToBlow.col})`);
            console.log(`-> Joueur fautif: ${currentPlayer}`);

            applyBlownRule(pieceToBlow.row, pieceToBlow.col);
            return;
        } else {
            console.log('-> Pas de r√®gle souffler √† appliquer (d√©sactiv√©e ou pas de faute)');
        }

        // Changer de joueur
        currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
        console.log(`\n-> Changement de joueur: maintenant c'est ${currentPlayer}`);

        // R√©initialiser pour le prochain tour
        piecesThatCouldCapture = [];
        checkMustCapture();
        console.log(`-> Le nouveau joueur (${currentPlayer}) a des captures disponibles: ${piecesThatCouldCapture.length > 0}`);

        updateStatus();
        checkWinner();

        if (gameMode === 'bot') {
            const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
            if (currentPlayer === botColor) {
                const t = setTimeout(botMove, 500);
                timeouts.push(t);
            }
        }

        renderBoard();
    }

    function blowAwayPiece(row, col) {
        const boardEl = document.getElementById('board');
        const squares = boardEl.children;
        const index = row * COLS + col;
        const square = squares[index];
        const pieceEl = square.querySelector('.piece');
        if (pieceEl) {
            pieceEl.classList.add('blown-away');
        }
    }

    function checkMustCapture() {
        mustCapture = false;
        piecesThatCouldCapture = [];

        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const piece = board[row][col];
                if (piece && piece.color === currentPlayer) {
                    const moves = getValidMoves(row, col);
                    if (moves.some(m => m.isCapture)) {
                        mustCapture = true;
                        piecesThatCouldCapture.push({ row, col });
                    }
                }
            }
        }
        // If prioritization is enabled, prefer queens first in the list
        if (CONFIG.prioritizeQueenCapture) {
            piecesThatCouldCapture.sort((a,b) => {
                const pa = board[a.row] && board[a.row][a.col];
                const pb = board[b.row] && board[b.row][b.col];
                const aIsKing = pa && pa.isKing;
                const bIsKing = pb && pb.isKing;
                return (bIsKing ? 1 : 0) - (aIsKing ? 1 : 0);
            });
        }
        return mustCapture;
    }

    function applyBlownRule(fromRow, fromCol) {
        // Show message first, then animate the piece away after message removed
        showBlownMessage();

        // After the message disappears (4s + 1s fade) wait 1s then animate piece and remove it
        // timeline: 4s visible +1s fade = 5s removal, +1s = 6s before animation
        const t1 = setTimeout(() => {
            const boardEl = document.getElementById('board');
            const squares = boardEl.children;
            const index = fromRow * COLS + fromCol;
            const square = squares[index];
            const pieceEl = square ? square.querySelector('.piece') : null;
            if (pieceEl) {
                // Add animation class
                pieceEl.classList.add('blown-away');
                // After animation ends (1s), remove the piece from board model and DOM
                const t2 = setTimeout(() => {
                    board[fromRow][fromCol] = null;
                    // update turn and state
                    currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
                    piecesThatCouldCapture = [];
                    checkMustCapture();
                    updateStatus();
                    renderBoard();
                    checkWinner();

                    if (gameMode === 'bot') {
                        const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
                        if (currentPlayer === botColor) {
                            const t3 = setTimeout(botMove, 500);
                            timeouts.push(t3);
                        }
                    }
                }, 1000);
                timeouts.push(t2);
            } else {
                // If there's no piece element in DOM, still remove from model and advance turn
                board[fromRow][fromCol] = null;
                currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
                piecesThatCouldCapture = [];
                checkMustCapture();
                updateStatus();
                renderBoard();
                checkWinner();

                if (gameMode === 'bot') {
                    const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
                    if (currentPlayer === botColor) {
                        const t3 = setTimeout(botMove, 500);
                        timeouts.push(t3);
                    }
                }
            }
        }, 6000);
        timeouts.push(t1);
    }

    function showBlownMessage() {
        const message = document.createElement('div');
        message.className = 'blown-message';
        message.innerHTML = "üå¨Ô∏è<br>Souffler n'est pas jouer !<br>Vous perdez votre pion !";
        // ensure starting fully visible
        message.style.opacity = '1';
        document.body.appendChild(message);
        // After 4s keep visible, then fade out over 1s
        const fadeStart = setTimeout(() => {
            message.style.transition = 'opacity 1s, transform 1s';
            message.style.opacity = '0';
            message.style.transform = 'scale(0.95)';
        }, 4000);
        const removeTimeout = setTimeout(() => {
            message.remove();
        }, 5000);
        timeouts.push(fadeStart, removeTimeout);
        return removeTimeout;
    }

    function showQueenPenaltyMessage() {
        const message = document.createElement('div');
        message.className = 'blown-message';
        message.style.background = 'rgba(255,165,0,0.95)';
        message.innerHTML = "‚ö†Ô∏è<br>Priorit√© aux dames !<br>Une dame a √©t√© r√©trograd√©e en pion.";
        message.style.opacity = '1';
        document.body.appendChild(message);
        // Fade after 4s, remove at 5s
        const fadeStart = setTimeout(() => {
            message.style.transition = 'opacity 1s, transform 1s';
            message.style.opacity = '0';
            message.style.transform = 'scale(0.95)';
        }, 4000);
        const removeTimeout = setTimeout(() => {
            message.remove();
        }, 5000);
        timeouts.push(fadeStart, removeTimeout);
        return removeTimeout;
    }

    function getAllValidMoves(color) {
        const allMoves = [];
        let hasCaptures = false;

        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const piece = board[row][col];
                if (piece && piece.color === color) {
                    const moves = getValidMoves(row, col);
                    if (moves.some(m => m.isCapture)) {
                        hasCaptures = true;
                    }
                    moves.forEach(move => {
                        allMoves.push({
                            fromRow: row,
                            fromCol: col,
                            toRow: move.row,
                            toCol: move.col,
                            isCapture: move.isCapture || false
                        });
                    });
                }
            }
        }

        if (hasCaptures) {
                let caps = allMoves.filter(m => m.isCapture);
                // If prioritization enabled, prefer captures performed by queens (isKing) first.
                if (CONFIG.prioritizeQueenCapture) {
                    caps.sort((a,b) => {
                        const aPiece = board[a.fromRow] && board[a.fromRow][a.fromCol];
                        const bPiece = board[b.fromRow] && board[b.fromRow][b.fromCol];
                        const aIsKing = aPiece && aPiece.isKing;
                        const bIsKing = bPiece && bPiece.isKing;
                        return (bIsKing ? 1 : 0) - (aIsKing ? 1 : 0);
                    });
                }
                return caps;
        }

        return allMoves;
    }

    function botMove() {
        const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
        let move = null;
        if (CONFIG.botLevel === 'easy') {
            // choose a random legal move
            const moves = getAllValidMoves(botColor);
            if (moves.length === 0) return;
            move = moves[Math.floor(Math.random() * moves.length)];
        } else if (CONFIG.botLevel === 'medium') {
            move = getBestMove(botColor, 4);
        } else if (CONFIG.botLevel === 'hard') {
            // use a much stronger search for hard level: deeper iterative deepening and larger time budget
            // WARNING: large time budgets may make the browser tab unresponsive during thinking.
            // We use iterative deepening with quiescence + transposition table already implemented in getBestMoveTimed.
            // Increase depth and time to make the bot extremely hard to beat.
            // Compute time limit from CONFIG.botThinkTime; allow 'max' option which maps to MAX_BOT_THINK_MS
            let timeLimitMs = 20000;
            try {
                if (CONFIG.botThinkTime === 'max') {
                    timeLimitMs = MAX_BOT_THINK_MS;
                } else if (typeof CONFIG.botThinkTime === 'string') {
                    const parsed = parseInt(CONFIG.botThinkTime, 10);
                    if (!isNaN(parsed) && parsed > 0) timeLimitMs = Math.min(parsed, MAX_BOT_THINK_MS);
                } else if (typeof CONFIG.botThinkTime === 'number') {
                    timeLimitMs = Math.min(CONFIG.botThinkTime, MAX_BOT_THINK_MS);
                }
            } catch (e) { /* fallback to default */ }
            move = getBestMoveTimed(botColor, 28, timeLimitMs); // depth 28, time limited by selection
        } else {
            move = getBestMove(botColor, 4);
        }

        if (move) {
            makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
            renderBoard();
        }
    }

    // Iterative deepening with transposition cache and move ordering
    function getBestMoveTimed(color, maxDepth, timeLimitMs) {
        const moves = getAllValidMoves(color);
        if (moves.length === 0) return null;

        function moveHeuristic(m) {
            // Improved lightweight heuristic for move ordering in timed search
            let s = 0;
            const fromPiece = board[m.fromRow] && board[m.fromRow][m.fromCol];
            const toPiece = board[m.toRow] && board[m.toRow][m.toCol];
            if (m.isCapture) {
                // reward captures strongly; prefer capturing kings
                const captured = (m.capturedRow !== undefined) ? (board[m.capturedRow] && board[m.capturedRow][m.capturedCol]) : null;
                if (captured) s += (captured.isKing ? 300 : 120);
                else s += 120;
            }
            if (fromPiece && fromPiece.isKing) s += 60; // kings are powerful movers
            // promotion opportunity (landing on last rank)
            if (fromPiece && !fromPiece.isKing) {
                if ((fromPiece.color === 'red' && m.toRow === 0) || (fromPiece.color === 'black' && m.toRow === 7)) {
                    s += 200;
                }
            }
            // small centralization bonus
            const centerDist = Math.abs(3.5 - m.toCol) + Math.abs(3.5 - m.toRow);
            s += Math.max(0, 20 - centerDist * 3);
            return s;
        }
        moves.sort((a,b) => moveHeuristic(b) - moveHeuristic(a));

        const transposition = new Map();
        const startTime = Date.now();
        let bestOverall = moves[0];
        // Quiescence search (capture-only extension)
        function quiescence(alpha, beta, color, startTime, timeLimit) {
            const stand = evaluateBoard(color);
            if (stand >= beta) return beta;
            if (alpha < stand) alpha = stand;
            // generate capture moves only
            const captures = getAllValidMoves(color).filter(m => m.isCapture);
            for (const mv of captures) {
                if (Date.now() - startTime > timeLimit) break;
                const copy = JSON.parse(JSON.stringify(board));
                makeTestMove(mv);
                const score = -quiescence(-beta, -alpha, (color === 'red' ? 'black' : 'red'), startTime, timeLimit);
                board = copy;
                if (score >= beta) return beta;
                if (score > alpha) alpha = score;
            }
            return alpha;
        }

        function minimaxWithCache(d, isMax, alpha, beta, rootColor) {
            const key = ZOBRIST.computeKey(board) ^ (rootColor === 'red' ? 0 : 0);
            const entry = transposition.get(key);
            if (entry && entry.depth >= d) return entry.score;

            // timeout check
            if (Date.now() - startTime > timeLimitMs) return evaluateBoard(rootColor);

            let val;
            if (d === 0) {
                // quiescence at leaf
                val = quiescence(alpha, beta, rootColor, startTime, timeLimitMs);
            } else {
                val = minimax(d, isMax, alpha, beta, rootColor);
            }

            transposition.set(key, { depth: d, score: val });
            return val;
        }

        for (let depth = 1; depth <= maxDepth; depth++) {
            if (Date.now() - startTime > timeLimitMs) break;
            let bestScore = -Infinity;
            let bestMove = null;

            for (const move of moves) {
                if (Date.now() - startTime > timeLimitMs) break;
                const boardCopy = JSON.parse(JSON.stringify(board));
                makeTestMove(move);
                const score = minimaxWithCache(depth - 1, false, -Infinity, Infinity, color);
                board = boardCopy;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            if (bestMove) bestOverall = bestMove;
        }

        return bestOverall;
    }

    function getBestMove(color, depth) {
        // For performance, use move ordering (captures first, then kings)
        const moves = getAllValidMoves(color);
        if (moves.length === 0) return null;

        function scoreMoveHeuristic(m) {
            let score = 0;
            if (m.isCapture) score += 100;
            const toPiece = board[m.toRow] && board[m.toRow][m.toCol];
            if (toPiece && toPiece.isKing) score += 20;
            return score;
        }

        moves.sort((a,b) => scoreMoveHeuristic(b) - scoreMoveHeuristic(a));

        let bestMove = moves[0];
        let bestScore = -Infinity;

    // Simple transposition cache using Zobrist keys
    const transposition = new Map();
    const startTime = Date.now();
    const timeLimit = 2000; // safety cap when called directly

        function minimaxWithCache(d, isMax, alpha, beta, rootColor) {
            const key = ZOBRIST.computeKey(board);
            if (transposition.has(key) && transposition.get(key).depth >= d) {
                return transposition.get(key).score;
            }

            if (Date.now() - startTime > timeLimit) {
                return evaluateBoard(rootColor);
            }

            const val = minimax(d, isMax, alpha, beta, rootColor);
            transposition.set(key, { depth: d, score: val });
            return val;
        }

        for (const move of moves) {
            const boardCopy = JSON.parse(JSON.stringify(board));
            makeTestMove(move);
            const score = minimax(depth - 1, false, -Infinity, Infinity, color, transposition, startTime, timeLimit);
            board = boardCopy;

            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
        }

        return bestMove;
    }

    // minimax with optional transposition cache and time budget
    function minimax(depth, isMaximizing, alpha, beta, color, transpositionMap = null, startTime = 0, timeLimit = Infinity) {
        if (Date.now() - startTime > timeLimit) {
            return evaluateBoard(color);
        }

        if (depth === 0) {
            return evaluateBoard(color);
        }

        const player = isMaximizing ? color : (color === 'red' ? 'black' : 'red');
        const moves = getAllValidMoves(player);

        if (moves.length === 0) {
            return isMaximizing ? -10000 : 10000;
        }

        if (isMaximizing) {
            let maxScore = -Infinity;
            for (const move of moves) {
                const boardCopy = JSON.parse(JSON.stringify(board));
                makeTestMove(move);
                const score = minimax(depth - 1, false, alpha, beta, color, transpositionMap, startTime, timeLimit);
                board = boardCopy;
                maxScore = Math.max(maxScore, score);
                alpha = Math.max(alpha, score);
                if (beta <= alpha) break;
            }
            return maxScore;
        } else {
            let minScore = Infinity;
            for (const move of moves) {
                const boardCopy = JSON.parse(JSON.stringify(board));
                makeTestMove(move);
                const score = minimax(depth - 1, true, alpha, beta, color, transpositionMap, startTime, timeLimit);
                board = boardCopy;
                minScore = Math.min(minScore, score);
                beta = Math.min(beta, score);
                if (beta <= alpha) break;
            }
            return minScore;
        }
    }

    function makeTestMove(move) {
        const piece = board[move.fromRow][move.fromCol];
        board[move.toRow][move.toCol] = piece;
        board[move.fromRow][move.fromCol] = null;

        if (Math.abs(move.toRow - move.fromRow) >= 2) {
            const dr = move.toRow > move.fromRow ? 1 : -1;
            const dc = move.toCol > move.fromCol ? 1 : -1;

            if (piece.isKing) {
                for (let i = 1; i < Math.abs(move.toRow - move.fromRow); i++) {
                    const checkRow = move.fromRow + dr * i;
                    const checkCol = move.fromCol + dc * i;
                    if (board[checkRow][checkCol]) {
                        board[checkRow][checkCol] = null;
                        break;
                    }
                }
            } else {
                const capturedRow = (move.fromRow + move.toRow) / 2;
                const capturedCol = (move.fromCol + move.toCol) / 2;
                board[capturedRow][capturedCol] = null;
            }
        }

        if ((piece.color === 'red' && move.toRow === 0) || (piece.color === 'black' && move.toRow === 7)) {
            piece.isKing = true;
        }
    }

    function evaluateBoard(color) {
        let score = 0;
        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const piece = board[row][col];
                if (piece) {
                    // stronger piece values for harder engine
                    const value = piece.isKing ? 320 : 100;
                    const positionBonus = piece.color === 'black' ? row * 4 : (7 - row) * 4;
                    if (piece.color === color) {
                        score += value + positionBonus;
                    } else {
                        score -= value + positionBonus;
                    }
                }
            }
        }
        // mobility bonus: number of moves for 'color' minus opponent
        const myMoves = getAllValidMoves(color).length;
        const oppMoves = getAllValidMoves(color === 'red' ? 'black' : 'red').length;
        score += (myMoves - oppMoves) * 8;
        return score;
    }

    function checkWinner() {
        const redMoves = getAllValidMoves('red');
        const blackMoves = getAllValidMoves('black');

        if (redMoves.length === 0) {
            if (gameMode === 'bot') {
                updateStatus('Le Robot Erwann a gagn√© !');
            } else {
                updateStatus('Mamie a gagn√© !');
            }
            gameMode = null;
            // After showing the winner for a short time, reset app to initial state
            const t = setTimeout(() => initializeAppState(), 3000);
            timeouts.push(t);
        } else if (blackMoves.length === 0) {
            if (gameMode === 'bot') {
                updateStatus('Vous avez gagn√© !');
            } else {
                updateStatus('Papy a gagn√© !');
            }
            gameMode = null;
            const t = setTimeout(() => initializeAppState(), 3000);
            timeouts.push(t);
        }
    }

    function initializeAppState() {
        // Cancel any pending timeouts
        while (timeouts.length) {
            clearTimeout(timeouts.pop());
        }

        // Reset all persisted choices and temporary state to initial app start values
        persistedHumanColor = 'red';
        persistedHumanLabel = 'Papy';
        persistedStarter = undefined;
        startGame.startingPlayer = undefined;
        gameMode = null;
    // Restore persisted config (do not force defaults here so user's preferences survive)
    // Note: do not access localStorage automatically during install/start to avoid runtime
    // prompts in some WebView environments. Settings are loaded lazily when the user
    // opens the Settings dialog.
    const tb = document.getElementById('settings-backward');
    const ts = document.getElementById('settings-souffler');
    const tpq = document.getElementById('settings-prioritize-queen');
    const tThink = document.getElementById('settings-bot-think');
    const tThinkRow = document.getElementById('settings-bot-think-row');
    if (tb) tb.checked = !!CONFIG.allowBackwardMoves;
    if (ts) ts.checked = !!CONFIG.enableSoufflerRule;
    if (tpq) tpq.checked = !!CONFIG.prioritizeQueenCapture;
    if (tThink) tThink.value = CONFIG.botThinkTime || '20000';
    if (tThinkRow) tThinkRow.style.display = (CONFIG.botLevel === 'hard') ? 'flex' : 'none';

        // Reinitialize board/UI to initial state
        initBoard();
        selectedPiece = null;
        validMoves = [];
        mustCapture = false;
        continuousCapture = false;
        piecesThatCouldCapture = [];
        currentPlayer = 'red';
    lastMove = null;
        renderBoard();
        updateStatus('S√©lectionnez un mode de jeu');
        hideModal();
    }

    function updateStatus(message) {
        const status = document.getElementById('status');
        if (message) {
            status.textContent = message;
        } else if (gameMode === 'bot') {
            const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
            if (currentPlayer === persistedHumanColor) {
                status.textContent = `√Ä vous de jouer (${persistedHumanLabel})`;
            } else if (currentPlayer === botColor) {
                status.textContent = 'Le Robot Erwann r√©fl√©chit...';
            }
        } else if (gameMode === 'pvp') {
            status.textContent = currentPlayer === 'red' ? 'Tour de Papy (Rouge)' : 'Tour de Mamie (Noir)';
        }
    }

    function startGame(mode) {
        // mode can be 'pvp' or 'bot'. This function may be called with an explicit starting player by other code.
        gameMode = mode;
        // If a persistedHumanColor was set (from the modal), use it as the starting player for human-side modes.
        // For pvp (play together) persistedHumanColor represents who starts (red or black).
    // Always use explicit startingPlayer when provided; otherwise default to persistedHumanColor.
    // Do NOT auto-use persistedStarter here so the starter modal can be shown each new game.
    currentPlayer = (typeof startGame.startingPlayer !== 'undefined') ? startGame.startingPlayer : persistedHumanColor;
        selectedPiece = null;
        validMoves = [];
        mustCapture = false;
        continuousCapture = false;
        piecesThatCouldCapture = [];
        initBoard();
        checkMustCapture();
        renderBoard();
        updateStatus();
        // If playing against the bot and the bot starts, let it play immediately
        if (gameMode === 'bot') {
            const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
            if (currentPlayer === botColor) {
                const t = setTimeout(botMove, 500);
                timeouts.push(t);
            }
        }
    }

    function resetGame() {
        const previousMode = gameMode || 'pvp';
        // When resetting, reuse the persistedHumanColor choice so the user's choice remains.
        // Clear any stored starting preference so the modal flow repeats each new game
        startGame.startingPlayer = undefined;
        // Clear persistedStarter so the next game prompts again
        persistedStarter = undefined;
        // Cancel any pending timeouts
        while (timeouts.length) {
            clearTimeout(timeouts.pop());
        }
        // Reset persisted choices as user requested full reset (but keep UI settings)
        persistedHumanColor = 'red';
        persistedHumanLabel = 'Papy';
        gameMode = null;
    // NOTE: preserve CONFIG (user settings) on reset: do NOT reset CONFIG flags here so the user's
    // preferences (like Prioriser capture par la dame) survive a Reset action.
    const tb = document.getElementById('settings-backward');
    const ts = document.getElementById('settings-souffler');
    const tpq = document.getElementById('settings-prioritize-queen');
    const tThink = document.getElementById('settings-bot-think');
    const tThinkRow = document.getElementById('settings-bot-think-row');
    if (tb) tb.checked = CONFIG.allowBackwardMoves;
    if (ts) ts.checked = CONFIG.enableSoufflerRule;
    if (tpq) tpq.checked = CONFIG.prioritizeQueenCapture;
    if (tThink) tThink.value = CONFIG.botThinkTime || '20000';
    if (tThinkRow) tThinkRow.style.display = (CONFIG.botLevel === 'hard') ? 'flex' : 'none';
        // Close modal if open
        hideModal();
        // Reinitialize board/UI but do not auto-start a game; user will choose mode and starter again
        initBoard();
        selectedPiece = null;
        validMoves = [];
        mustCapture = false;
        continuousCapture = false;
        piecesThatCouldCapture = [];
        currentPlayer = 'red';
    lastMove = null;
        renderBoard();
        updateStatus('S√©lectionnez un mode de jeu');
    }

    // --- Modal and button wiring ---
    const btnPlayTogether = document.getElementById('btn-play-together');
    const btnPlaySolo = document.getElementById('btn-play-solo');
    const modal = document.getElementById('choiceModal');
    const modalTitle = document.getElementById('modalTitle');
    let choosePapy = document.getElementById('choosePapy');
    let chooseMamie = document.getElementById('chooseMamie');

    let modalContext = null; // 'pvp' or 'bot'
    let persistedHumanLabel = 'Papy';

    btnPlayTogether.addEventListener('click', () => {
        modalContext = 'pvp';
        // ensure previous starter isn't reused so modal always prompts
        startGame.startingPlayer = undefined;
        persistedStarter = undefined;
        // Show normal Papy/Mamie choice to decide who starts
        // Ensure the modal buttons run the first-step handlers
        choosePapy.onclick = firstStepPapy;
        chooseMamie.onclick = firstStepMamie;
        choosePapy.textContent = 'Papy (Rouge)';
        chooseMamie.textContent = 'Mamie (Noir)';
        modalTitle.textContent = 'Qui commence ?';
        showModal();
    });

    btnPlaySolo.addEventListener('click', () => {
        modalContext = 'bot';
        // ensure previous starter isn't reused so modal always prompts
        startGame.startingPlayer = undefined;
        persistedStarter = undefined;
        // In bot mode, first choose which label represents the human; human will always be RED.
        // Ensure the modal buttons run the first-step handlers
        choosePapy.onclick = firstStepPapy;
        chooseMamie.onclick = firstStepMamie;
        choosePapy.textContent = 'Papy (Rouge)';
        chooseMamie.textContent = 'Mamie (Rouge)';
        modalTitle.textContent = 'Qui jouera contre le Robot Erwann ?';
        showModal();
    });

    // Define first-step handlers for the modal buttons (Papy / Mamie)
    function firstStepPapy() {
        if (modalContext === 'pvp') {
            // Papy starts as RED
            persistedHumanColor = 'red';
            startGame.startingPlayer = 'red';
            persistedStarter = 'red';
            hideModal();
            startGame('pvp');
            return;
        }

        // Bot mode: human label = Papy, human color = RED
        persistedHumanLabel = 'Papy';
        persistedHumanColor = 'red';
        // Next ask who starts (player or bot)
        showStarterModal();
    }

    function firstStepMamie() {
        if (modalContext === 'pvp') {
            // Mamie starts as BLACK
            persistedHumanColor = 'black';
            startGame.startingPlayer = 'black';
            persistedStarter = 'black';
            hideModal();
            startGame('pvp');
            return;
        }

        // Bot mode: human label = Mamie, but human color is still RED (user wants to play as Mamie but keep RED)
        persistedHumanLabel = 'Mamie';
        persistedHumanColor = 'red';
        // Next ask who starts (player or bot)
        showStarterModal();
    }

    // Attach these as the default first-step handlers when the modal is shown by Play buttons
    // (btnPlayTogether and btnPlaySolo set choosePapy.onclick/chooseMamie.onclick below)

    function showStarterModal() {
        modalTitle.textContent = 'Qui commence ?';
        // Configure buttons for the starter choice step (player vs bot)
        choosePapy.textContent = `Le joueur (${persistedHumanLabel})`;
        chooseMamie.textContent = 'Le Robot Erwann';

        // Replace onclick handlers for this step
        choosePapy.onclick = () => {
            hideModal();
            startGame.startingPlayer = 'red';
            persistedStarter = 'red';
            startGame('bot');
        };

        chooseMamie.onclick = () => {
            hideModal();
            startGame.startingPlayer = 'black';
            persistedStarter = 'black';
            startGame('bot');
        };
    }

    function showModal() {
        modal.style.display = 'flex';
    }

    function hideModal() {
        modal.style.display = 'none';
    }

    // Do not load persisted settings on startup to avoid possible install-time prompts.
    initBoard();
    renderBoard();

    // Wire settings modal UI
    const btnSettings = document.getElementById('btn-settings');
    const settingsModal = document.getElementById('settingsModal');
    const settingsBackward = document.getElementById('settings-backward');
    const settingsSouffler = document.getElementById('settings-souffler');
    const settingsPrioritizeQueen = document.getElementById('settings-prioritize-queen');
    const settingsBotLevel = document.getElementById('settings-bot-level');
    const settingsBotThink = document.getElementById('settings-bot-think');
    const settingsSave = document.getElementById('settings-save');
    const settingsCancel = document.getElementById('settings-cancel');
    const settingsCancel2 = document.getElementById('settings-cancel-2');

    if (btnSettings) {
        btnSettings.addEventListener('click', () => {
            // Load persisted settings right when the user opens the modal (lazy load)
            try { loadSettingsFromStorage(); } catch(e) { console.warn('Could not lazy-load settings', e); }
            if (settingsModal) settingsModal.style.display = 'flex';
            // set UI from CONFIG
            if (settingsBackward) settingsBackward.checked = CONFIG.allowBackwardMoves;
            if (settingsSouffler) settingsSouffler.checked = CONFIG.enableSoufflerRule;
            if (settingsPrioritizeQueen) settingsPrioritizeQueen.checked = CONFIG.prioritizeQueenCapture;
            if (settingsBotLevel) settingsBotLevel.value = CONFIG.botLevel || 'medium';
            // show/hide the think-time row when difficulty is hard
            const thinkRow = document.getElementById('settings-bot-think-row');
            if (thinkRow) thinkRow.style.display = (settingsBotLevel && settingsBotLevel.value === 'hard') ? 'flex' : 'none';
            if (settingsBotThink) {
                settingsBotThink.value = CONFIG.botThinkTime || '20000';
                try { updateBotThinkWarning(); } catch (e) { /* ignore if not defined */ }
            }
        });
    }

    // Toggle visibility of the bot-think option when user changes bot difficulty inside the modal
    if (settingsBotLevel) {
        settingsBotLevel.addEventListener('change', (e) => {
            const thinkRow = document.getElementById('settings-bot-think-row');
            if (!thinkRow) return;
            thinkRow.style.display = (settingsBotLevel.value === 'hard') ? 'flex' : 'none';
            // update warning visibility when toggling the row
            try { updateBotThinkWarning(); } catch (e) { /* ignore if not initialized */ }
        });
    }

    // Show a warning when bot think time is long (>10s) or set to 'max'
    function updateBotThinkWarning() {
        const warnEl = document.getElementById('settings-bot-warning');
        const thinkSel = document.getElementById('settings-bot-think');
        const thinkRow = document.getElementById('settings-bot-think-row');
        if (!warnEl || !thinkSel || !thinkRow) return;
        // only show when the row is visible
        if (thinkRow.style.display === 'none' || thinkRow.style.display === '') {
            warnEl.style.display = 'none';
            return;
        }
        const v = thinkSel.value;
        let show = false;
        if (v === 'max') show = true;
        else {
            const parsed = parseInt(v, 10);
            if (!isNaN(parsed) && parsed > 10000) show = true;
        }
        warnEl.style.display = show ? 'block' : 'none';
    }

    if (settingsBotThink) {
        settingsBotThink.addEventListener('change', updateBotThinkWarning);
    }

    function closeSettingsModal() {
        if (settingsModal) settingsModal.style.display = 'none';
    }

    // Save button applies settings
    if (settingsSave) {
        settingsSave.addEventListener('click', () => {
            if (settingsBackward) CONFIG.allowBackwardMoves = settingsBackward.checked;
            if (settingsSouffler) CONFIG.enableSoufflerRule = settingsSouffler.checked;
            const settingsPrioritizeQueen = document.getElementById('settings-prioritize-queen');
            if (settingsPrioritizeQueen) CONFIG.prioritizeQueenCapture = settingsPrioritizeQueen.checked;
            if (settingsBotLevel) CONFIG.botLevel = settingsBotLevel.value;
            const settingsThinkSel = document.getElementById('settings-bot-think');
            if (settingsThinkSel) CONFIG.botThinkTime = settingsThinkSel.value;
            console.log('CONFIG updated', CONFIG);
            // Persist the user's preferences so they survive app restart
            saveSettingsToStorage();
            // Recompute visuals / state
            selectedPiece = null;
            validMoves = [];
            renderBoard();
            closeSettingsModal();
        });
    }

    // Cancel buttons simply close without applying
    // settings-cancel removed (close is handled by Cancel button and clicking outside modal)
    if (settingsCancel2) settingsCancel2.addEventListener('click', closeSettingsModal);

    // Close settings modal on outside click
    if (settingsModal) {
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.style.display = 'none';
            }
        });
    }
</script>
</body>
</html>