<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de Dames</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }

        .btn-pvp {
            background: #4CAF50;
            color: white;
        }

        .btn-bot {
            background: #2196F3;
            color: white;
        }

        .btn-reset {
            background: #f44336;
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .status {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 8px;
            background: #f0f0f0;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            aspect-ratio: 1;
            border: 4px solid #333;
            border-radius: 8px;
            overflow: hidden;
            margin: 0 auto;
            max-width: 500px;
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square.selected {
            background: #7fc97f !important;
        }

        .square.valid-move {
            background: #90ee90 !important;
        }

        .square.must-capture {
            /* Removed red background */
        }

        .blown-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            animation: blownMessageAnim 4s ease-in-out;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        @keyframes blownMessageAnim {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            10% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            85% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
        }

        @keyframes pulse {
            0%, 100% { background: #ffcccc !important; }
            50% { background: #ff9999 !important; }
        }

        @keyframes blowAway {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.5) rotate(180deg); opacity: 0.5; }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }

        .piece {
            width: 70%;
            height: 70%;
            border-radius: 50%;
            border: 3px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #c92a2a);
            color: white;
        }

        .piece.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #1a1a1a);
            color: white;
        }

        .piece:hover {
            transform: scale(1.1);
        }

        .piece.blown-away {
            animation: blowAway 0.8s ease-out forwards;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.5em;
            }

            button {
                padding: 10px 15px;
                font-size: 14px;
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>üéØ Jeu de Dames</h1>
    <div class="controls">
        <button class="btn-pvp" id="btn-play-together">Jouer √† deux</button>
        <button class="btn-bot" id="btn-play-solo">Jouer en solo contre le Robot Erwann</button>
        <button class="btn-reset" onclick="resetGame()">R√©initialiser</button>
    </div>
    <div class="status" id="status">S√©lectionnez un mode de jeu</div>
    <div class="board" id="board"></div>
</div>

<!-- Modal for choosing who starts / who plays -->
<div id="choiceModal" class="modal" style="display:none;">
    <div class="modal-content">
        <h2 id="modalTitle">Qui commence ?</h2>
        <div class="modal-buttons">
            <button id="choosePapy" class="btn-modal">Papy (Rouge)</button>
            <button id="chooseMamie" class="btn-modal">Mamie (Noir)</button>
        </div>
    </div>
</div>

<style>
    /* Modal styles */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }

    .modal-content {
        background: white;
        padding: 24px;
        border-radius: 12px;
        text-align: center;
        max-width: 320px;
        width: 90%;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .modal-buttons {
        display: flex;
        gap: 12px;
        margin-top: 16px;
        justify-content: center;
    }

    .btn-modal {
        padding: 10px 14px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: bold;
        min-width: 110px;
    }

    #choosePapy { background: #4CAF50; color: white; }
    #chooseMamie { background: #2196F3; color: white; }
</style>

<script>
    const ROWS = 8;
    const COLS = 8;
    let board = [];
    let selectedPiece = null;
    let currentPlayer = 'red';
    let gameMode = null;
    let validMoves = [];
    let mustCapture = false;
    let continuousCapture = false;
    let piecesThatCouldCapture = [];
    // Persisted choice: who is the human when playing vs bot or who starts when playing together
    let persistedHumanColor = 'red'; // 'red' or 'black' - default red
    let persistedStarter = undefined; // 'red' or 'black' - who started last (persist across resets)
    let timeouts = [];

    function initBoard() {
        board = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));

        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < COLS; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { color: 'black', isKing: false };
                }
            }
        }

        for (let row = 5; row < 8; row++) {
            for (let col = 0; col < COLS; col++) {
                if ((row + col) % 2 === 1) {
                    board[row][col] = { color: 'red', isKing: false };
                }
            }
        }
    }

    function renderBoard() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';

        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const square = document.createElement('div');
                square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                square.dataset.row = row;
                square.dataset.col = col;

                if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                    square.classList.add('selected');
                }

                if (validMoves.some(m => m.row === row && m.col === col)) {
                    square.classList.add('valid-move');
                }

                const piece = board[row][col];
                if (piece) {
                    const pieceEl = document.createElement('div');
                    pieceEl.className = `piece ${piece.color}`;
                    if (piece.isKing) {
                        pieceEl.textContent = '‚ôî';
                    }
                    square.appendChild(pieceEl);
                }

                square.addEventListener('click', () => handleSquareClick(row, col));
                boardEl.appendChild(square);
            }
        }
    }

    function handleSquareClick(row, col) {
        if (!gameMode) return;
        // If playing vs bot, ignore clicks when it's not the human's turn
        if (gameMode === 'bot') {
            const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
            if (currentPlayer === botColor) return;
        }

        const piece = board[row][col];

        console.log(`=== CLICK sur (${row}, ${col}) ===`);
        console.log(`Joueur actuel: ${currentPlayer}`);
        console.log(`Pi√®ce cliqu√©e:`, piece);
        console.log(`Continuous capture: ${continuousCapture}`);

        // Si on est en mode capture continue, on v√©rifie d'abord si on clique sur un mouvement de capture
        if (continuousCapture && selectedPiece) {
            console.log('-> Mode capture continue actif');
            const move = validMoves.find(m => m.row === row && m.col === col);
            if (move && move.isCapture) {
                console.log('-> Capture continue d√©tect√©e');
                makeMove(selectedPiece.row, selectedPiece.col, row, col);
                return;
            } else {
                console.log('-> Mouvement non valide en capture continue, d√©s√©lection');
                selectedPiece = null;
                validMoves = [];
                continuousCapture = false;
                renderBoard();
                return;
            }
        }

        if (selectedPiece) {
            console.log(`Pi√®ce d√©j√† s√©lectionn√©e: (${selectedPiece.row}, ${selectedPiece.col})`);
            const move = validMoves.find(m => m.row === row && m.col === col);
            if (move) {
                console.log('-> Mouvement valide trouv√©:', move);
                makeMove(selectedPiece.row, selectedPiece.col, row, col);
            } else if (piece && piece.color === currentPlayer) {
                console.log('-> Nouvelle pi√®ce s√©lectionn√©e');
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col);
                console.log('-> Mouvements valides:', validMoves);
            } else {
                console.log('-> D√©s√©lection');
                selectedPiece = null;
                validMoves = [];
            }
        } else if (piece && piece.color === currentPlayer) {
            console.log('-> Premi√®re s√©lection de pi√®ce');
            selectedPiece = { row, col };
            validMoves = getValidMoves(row, col);
            console.log('-> Mouvements valides:', validMoves);
        }

        renderBoard();
    }

    function getValidMoves(row, col) {
        const piece = board[row][col];
        if (!piece) return [];

        const moves = [];
        const captures = [];

        if (piece.isKing) {
            const directions = [[-1,-1], [-1,1], [1,-1], [1,1]];
            for (const [dr, dc] of directions) {
                for (let dist = 1; dist < ROWS; dist++) {
                    const newRow = row + dr * dist;
                    const newCol = col + dc * dist;

                    if (newRow < 0 || newRow >= ROWS || newCol < 0 || newCol >= COLS) break;

                    if (!board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol, isCapture: false });
                    } else if (board[newRow][newCol].color !== piece.color) {
                        for (let jumpDist = 1; jumpDist < ROWS; jumpDist++) {
                            const jumpRow = newRow + dr * jumpDist;
                            const jumpCol = newCol + dc * jumpDist;

                            if (jumpRow < 0 || jumpRow >= ROWS || jumpCol < 0 || jumpCol >= COLS) break;

                            if (!board[jumpRow][jumpCol]) {
                                captures.push({
                                    row: jumpRow,
                                    col: jumpCol,
                                    capturedRow: newRow,
                                    capturedCol: newCol,
                                    isCapture: true
                                });
                            } else {
                                break;
                            }
                        }
                        break;
                    } else {
                        break;
                    }
                }
            }
        } else {
            const directions = piece.color === 'red' ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]];

            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;

                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                    if (!board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol, isCapture: false });
                    } else if (board[newRow][newCol].color !== piece.color) {
                        const jumpRow = newRow + dr;
                        const jumpCol = newCol + dc;
                        if (jumpRow >= 0 && jumpRow < ROWS && jumpCol >= 0 && jumpCol < COLS && !board[jumpRow][jumpCol]) {
                            captures.push({
                                row: jumpRow,
                                col: jumpCol,
                                capturedRow: newRow,
                                capturedCol: newCol,
                                isCapture: true
                            });
                        }
                    }
                }
            }
        }

        if (captures.length > 0) {
            const maxCaptures = findMaxCaptures(row, col, piece);
            return maxCaptures;
        }

        return moves;
    }

    function findMaxCaptures(row, col, piece, captured = [], depth = 0) {
        const captureMoves = [];
        const directions = piece.isKing ?
            [[-1,-1], [-1,1], [1,-1], [1,1]] :
            piece.color === 'red' ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]];

        if (piece.isKing) {
            for (const [dr, dc] of directions) {
                for (let dist = 1; dist < ROWS; dist++) {
                    const enemyRow = row + dr * dist;
                    const enemyCol = col + dc * dist;

                    if (enemyRow < 0 || enemyRow >= ROWS || enemyCol < 0 || enemyCol >= COLS) break;

                    if (board[enemyRow][enemyCol]) {
                        if (board[enemyRow][enemyCol].color !== piece.color &&
                            !captured.some(c => c.row === enemyRow && c.col === enemyCol)) {
                            for (let jumpDist = 1; jumpDist < ROWS; jumpDist++) {
                                const jumpRow = enemyRow + dr * jumpDist;
                                const jumpCol = enemyCol + dc * jumpDist;

                                if (jumpRow < 0 || jumpRow >= ROWS || jumpCol < 0 || jumpCol >= COLS) break;

                                if (!board[jumpRow][jumpCol]) {
                                    captureMoves.push({
                                        row: jumpRow,
                                        col: jumpCol,
                                        capturedRow: enemyRow,
                                        capturedCol: enemyCol,
                                        isCapture: true,
                                        captureCount: captured.length + 1
                                    });
                                } else {
                                    break;
                                }
                            }
                        }
                        break;
                    }
                }
            }
        } else {
            for (const [dr, dc] of directions) {
                const enemyRow = row + dr;
                const enemyCol = col + dc;

                if (enemyRow >= 0 && enemyRow < ROWS && enemyCol >= 0 && enemyCol < COLS) {
                    if (board[enemyRow][enemyCol] &&
                        board[enemyRow][enemyCol].color !== piece.color &&
                        !captured.some(c => c.row === enemyRow && c.col === enemyCol)) {
                        const jumpRow = enemyRow + dr;
                        const jumpCol = enemyCol + dc;
                        if (jumpRow >= 0 && jumpRow < ROWS && jumpCol >= 0 && jumpCol < COLS && !board[jumpRow][jumpCol]) {
                            captureMoves.push({
                                row: jumpRow,
                                col: jumpCol,
                                capturedRow: enemyRow,
                                capturedCol: enemyCol,
                                isCapture: true,
                                captureCount: captured.length + 1
                            });
                        }
                    }
                }
            }
        }

        if (captureMoves.length === 0) {
            return depth === 0 ? [] : captured;
        }

        return captureMoves;
    }

    function makeMove(fromRow, fromCol, toRow, toCol) {
        console.log(`\n=== MAKE MOVE de (${fromRow},${fromCol}) vers (${toRow},${toCol}) ===`);
        const piece = board[fromRow][fromCol];

        let wasCapture = false;
        if (Math.abs(toRow - fromRow) >= 2) {
            wasCapture = true;
            console.log('-> C\'est une CAPTURE');
        } else {
            console.log('-> C\'est un mouvement NORMAL');
        }

        // D√©placer la pi√®ce
        board[toRow][toCol] = piece;
        board[fromRow][fromCol] = null;

        if (wasCapture) {
            const dr = toRow > fromRow ? 1 : -1;
            const dc = toCol > fromCol ? 1 : -1;

            if (piece.isKing) {
                for (let i = 1; i < Math.abs(toRow - fromRow); i++) {
                    const checkRow = fromRow + dr * i;
                    const checkCol = fromCol + dc * i;
                    if (board[checkRow][checkCol]) {
                        console.log(`-> Capture de la pi√®ce en (${checkRow}, ${checkCol})`);
                        blowAwayPiece(checkRow, checkCol);
                        board[checkRow][checkCol] = null;
                        break;
                    }
                }
            } else {
                const capturedRow = (fromRow + toRow) / 2;
                const capturedCol = (fromCol + toCol) / 2;
                console.log(`-> Capture de la pi√®ce en (${capturedRow}, ${capturedCol})`);
                blowAwayPiece(capturedRow, capturedCol);
                board[capturedRow][capturedCol] = null;
            }
        }

        // Promotion en dame
        if ((piece.color === 'red' && toRow === 0) || (piece.color === 'black' && toRow === 7)) {
            piece.isKing = true;
            console.log('-> Promotion en DAME !');
        }

        // V√©rifier les captures multiples
        if (wasCapture) {
            const nextCaptures = getValidMoves(toRow, toCol).filter(m => m.isCapture);

            if (nextCaptures.length > 0) {
                console.log('-> CAPTURES MULTIPLES possibles:', nextCaptures);
                selectedPiece = { row: toRow, col: toCol };
                validMoves = nextCaptures;
                continuousCapture = true;
                updateStatus(piece.color === 'red' ? "Prise multiple ! Continuez..." : "Le robot continue...");
                renderBoard();

                if (gameMode === 'bot') {
                    const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
                    if (currentPlayer === botColor) {
                        const t = setTimeout(botMove, 700);
                        timeouts.push(t);
                    }
                }
                return; // On reste sur le m√™me tour pour la capture suivante
            }
        }

        // Si pas de capture multiple, on termine le tour
        selectedPiece = null;
        validMoves = [];
        continuousCapture = false;

        console.log(`\n--- V√âRIFICATION R√àGLE SOUFFLER ---`);
        console.log(`wasCapture: ${wasCapture}`);
        console.log(`piecesThatCouldCapture:`, piecesThatCouldCapture);

        // Appliquer la r√®gle souffler si le joueur n'a pas fait de capture alors qu'il pouvait
        if (!wasCapture && piecesThatCouldCapture.length > 0) {
            console.log('üå¨Ô∏è APPLICATION DE LA R√àGLE SOUFFLER !');

            // Choisir une pi√®ce au hasard parmi celles qui pouvaient capturer
            const randomIndex = Math.floor(Math.random() * piecesThatCouldCapture.length);
            const pieceToBlow = piecesThatCouldCapture[randomIndex];

            console.log(`-> Pion √† souffler: (${pieceToBlow.row}, ${pieceToBlow.col})`);
            console.log(`-> Joueur fautif: ${currentPlayer}`);

            applyBlownRule(pieceToBlow.row, pieceToBlow.col);
            return;
        } else {
            console.log('-> Pas de r√®gle souffler √† appliquer');
        }

        // Changer de joueur
        currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
        console.log(`\n-> Changement de joueur: maintenant c'est ${currentPlayer}`);

        // R√©initialiser pour le prochain tour
        piecesThatCouldCapture = [];
        checkMustCapture();
        console.log(`-> Le nouveau joueur (${currentPlayer}) a des captures disponibles: ${piecesThatCouldCapture.length > 0}`);

        updateStatus();
        checkWinner();

        if (gameMode === 'bot') {
            const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
            if (currentPlayer === botColor) {
                const t = setTimeout(botMove, 500);
                timeouts.push(t);
            }
        }

        renderBoard();
    }

    function blowAwayPiece(row, col) {
        const boardEl = document.getElementById('board');
        const squares = boardEl.children;
        const index = row * COLS + col;
        const square = squares[index];
        const pieceEl = square.querySelector('.piece');
        if (pieceEl) {
            pieceEl.classList.add('blown-away');
        }
    }

    function checkMustCapture() {
        mustCapture = false;
        piecesThatCouldCapture = [];

        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const piece = board[row][col];
                if (piece && piece.color === currentPlayer) {
                    const moves = getValidMoves(row, col);
                    if (moves.some(m => m.isCapture)) {
                        mustCapture = true;
                        piecesThatCouldCapture.push({ row, col });
                    }
                }
            }
        }
        return mustCapture;
    }

    function applyBlownRule(fromRow, fromCol) {
        // Show message first, then animate the piece away after message removed
        showBlownMessage();

        // After the message disappears (4s), animate piece and then remove it
        const t1 = setTimeout(() => {
            const boardEl = document.getElementById('board');
            const squares = boardEl.children;
            const index = fromRow * COLS + fromCol;
            const square = squares[index];
            const pieceEl = square ? square.querySelector('.piece') : null;
            if (pieceEl) {
                // Add animation class
                pieceEl.classList.add('blown-away');
                // After animation ends (~0.8s), remove the piece from board model and DOM
                const t2 = setTimeout(() => {
                    board[fromRow][fromCol] = null;
                    // update turn and state
                    currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
                    piecesThatCouldCapture = [];
                    checkMustCapture();
                    updateStatus();
                    renderBoard();
                    checkWinner();

                    if (gameMode === 'bot') {
                        const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
                        if (currentPlayer === botColor) {
                            const t3 = setTimeout(botMove, 500);
                            timeouts.push(t3);
                        }
                    }
                }, 900);
                timeouts.push(t2);
            } else {
                // If there's no piece element in DOM, still remove from model and advance turn
                board[fromRow][fromCol] = null;
                currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
                piecesThatCouldCapture = [];
                checkMustCapture();
                updateStatus();
                renderBoard();
                checkWinner();

                if (gameMode === 'bot') {
                    const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
                    if (currentPlayer === botColor) {
                        const t3 = setTimeout(botMove, 500);
                        timeouts.push(t3);
                    }
                }
            }
        }, 4100);
        timeouts.push(t1);
    }

    function showBlownMessage() {
        const message = document.createElement('div');
        message.className = 'blown-message';
        message.innerHTML = "üå¨Ô∏è<br>Souffler n'est pas jouer !<br>Vous perdez votre pion !";
        document.body.appendChild(message);
        const t = setTimeout(() => {
            message.remove();
        }, 4000);
        timeouts.push(t);
        return t;
    }

    function getAllValidMoves(color) {
        const allMoves = [];
        let hasCaptures = false;

        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const piece = board[row][col];
                if (piece && piece.color === color) {
                    const moves = getValidMoves(row, col);
                    if (moves.some(m => m.isCapture)) {
                        hasCaptures = true;
                    }
                    moves.forEach(move => {
                        allMoves.push({
                            fromRow: row,
                            fromCol: col,
                            toRow: move.row,
                            toCol: move.col,
                            isCapture: move.isCapture || false
                        });
                    });
                }
            }
        }

        if (hasCaptures) {
            return allMoves.filter(m => m.isCapture);
        }

        return allMoves;
    }

    function botMove() {
        const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
        const move = getBestMove(botColor, 4);
        if (move) {
            makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
            renderBoard();
        }
    }

    function getBestMove(color, depth) {
        const moves = getAllValidMoves(color);
        if (moves.length === 0) return null;

        let bestScore = -Infinity;
        let bestMove = moves[0];

        for (const move of moves) {
            const boardCopy = JSON.parse(JSON.stringify(board));
            makeTestMove(move);
            const score = minimax(depth - 1, false, -Infinity, Infinity, color);
            board = boardCopy;

            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
        }

        return bestMove;
    }

    function minimax(depth, isMaximizing, alpha, beta, color) {
        if (depth === 0) {
            return evaluateBoard(color);
        }

        const player = isMaximizing ? color : (color === 'red' ? 'black' : 'red');
        const moves = getAllValidMoves(player);

        if (moves.length === 0) {
            return isMaximizing ? -10000 : 10000;
        }

        if (isMaximizing) {
            let maxScore = -Infinity;
            for (const move of moves) {
                const boardCopy = JSON.parse(JSON.stringify(board));
                makeTestMove(move);
                const score = minimax(depth - 1, false, alpha, beta, color);
                board = boardCopy;
                maxScore = Math.max(maxScore, score);
                alpha = Math.max(alpha, score);
                if (beta <= alpha) break;
            }
            return maxScore;
        } else {
            let minScore = Infinity;
            for (const move of moves) {
                const boardCopy = JSON.parse(JSON.stringify(board));
                makeTestMove(move);
                const score = minimax(depth - 1, true, alpha, beta, color);
                board = boardCopy;
                minScore = Math.min(minScore, score);
                beta = Math.min(beta, score);
                if (beta <= alpha) break;
            }
            return minScore;
        }
    }

    function makeTestMove(move) {
        const piece = board[move.fromRow][move.fromCol];
        board[move.toRow][move.toCol] = piece;
        board[move.fromRow][move.fromCol] = null;

        if (Math.abs(move.toRow - move.fromRow) >= 2) {
            const dr = move.toRow > move.fromRow ? 1 : -1;
            const dc = move.toCol > move.fromCol ? 1 : -1;

            if (piece.isKing) {
                for (let i = 1; i < Math.abs(move.toRow - move.fromRow); i++) {
                    const checkRow = move.fromRow + dr * i;
                    const checkCol = move.fromCol + dc * i;
                    if (board[checkRow][checkCol]) {
                        board[checkRow][checkCol] = null;
                        break;
                    }
                }
            } else {
                const capturedRow = (move.fromRow + move.toRow) / 2;
                const capturedCol = (move.fromCol + move.toCol) / 2;
                board[capturedRow][capturedCol] = null;
            }
        }

        if ((piece.color === 'red' && move.toRow === 0) || (piece.color === 'black' && move.toRow === 7)) {
            piece.isKing = true;
        }
    }

    function evaluateBoard(color) {
        let score = 0;
        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const piece = board[row][col];
                if (piece) {
                    const value = piece.isKing ? 30 : 10;
                    const positionBonus = piece.color === 'black' ? row : (7 - row);
                    if (piece.color === color) {
                        score += value + positionBonus;
                    } else {
                        score -= value + positionBonus;
                    }
                }
            }
        }
        return score;
    }

    function checkWinner() {
        const redMoves = getAllValidMoves('red');
        const blackMoves = getAllValidMoves('black');

        if (redMoves.length === 0) {
            if (gameMode === 'bot') {
                updateStatus('Le Robot Erwann a gagn√© !');
            } else {
                updateStatus('Mamie a gagn√© !');
            }
            gameMode = null;
            // After showing the winner for a short time, reset app to initial state
            const t = setTimeout(() => initializeAppState(), 3000);
            timeouts.push(t);
        } else if (blackMoves.length === 0) {
            if (gameMode === 'bot') {
                updateStatus('Vous avez gagn√© !');
            } else {
                updateStatus('Papy a gagn√© !');
            }
            gameMode = null;
            const t = setTimeout(() => initializeAppState(), 3000);
            timeouts.push(t);
        }
    }

    function initializeAppState() {
        // Cancel any pending timeouts
        while (timeouts.length) {
            clearTimeout(timeouts.pop());
        }

        // Reset all persisted choices and temporary state to initial app start values
        persistedHumanColor = 'red';
        persistedHumanLabel = 'Papy';
        persistedStarter = undefined;
        startGame.startingPlayer = undefined;
        gameMode = null;

        // Reinitialize board/UI to initial state
        initBoard();
        selectedPiece = null;
        validMoves = [];
        mustCapture = false;
        continuousCapture = false;
        piecesThatCouldCapture = [];
        currentPlayer = 'red';
        renderBoard();
        updateStatus('S√©lectionnez un mode de jeu');
        hideModal();
    }

    function updateStatus(message) {
        const status = document.getElementById('status');
        if (message) {
            status.textContent = message;
        } else if (gameMode === 'bot') {
            const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
            if (currentPlayer === persistedHumanColor) {
                status.textContent = `√Ä vous de jouer (${persistedHumanLabel})`;
            } else if (currentPlayer === botColor) {
                status.textContent = 'Le Robot Erwann r√©fl√©chit...';
            }
        } else if (gameMode === 'pvp') {
            status.textContent = currentPlayer === 'red' ? 'Tour de Papy (Rouge)' : 'Tour de Mamie (Noir)';
        }
    }

    function startGame(mode) {
        // mode can be 'pvp' or 'bot'. This function may be called with an explicit starting player by other code.
        gameMode = mode;
        // If a persistedHumanColor was set (from the modal), use it as the starting player for human-side modes.
        // For pvp (play together) persistedHumanColor represents who starts (red or black).
    // Always use explicit startingPlayer when provided; otherwise default to persistedHumanColor.
    // Do NOT auto-use persistedStarter here so the starter modal can be shown each new game.
    currentPlayer = (typeof startGame.startingPlayer !== 'undefined') ? startGame.startingPlayer : persistedHumanColor;
        selectedPiece = null;
        validMoves = [];
        mustCapture = false;
        continuousCapture = false;
        piecesThatCouldCapture = [];
        initBoard();
        checkMustCapture();
        renderBoard();
        updateStatus();
        // If playing against the bot and the bot starts, let it play immediately
        if (gameMode === 'bot') {
            const botColor = persistedHumanColor === 'red' ? 'black' : 'red';
            if (currentPlayer === botColor) {
                const t = setTimeout(botMove, 500);
                timeouts.push(t);
            }
        }
    }

    function resetGame() {
        const previousMode = gameMode || 'pvp';
        // When resetting, reuse the persistedHumanColor choice so the user's choice remains.
        // Clear any stored starting preference so the modal flow repeats each new game
        startGame.startingPlayer = undefined;
        // Clear persistedStarter so the next game prompts again
        persistedStarter = undefined;
        // Cancel any pending timeouts
        while (timeouts.length) {
            clearTimeout(timeouts.pop());
        }
        // Reset persisted choices as user requested full reset
        persistedHumanColor = 'red';
        persistedHumanLabel = 'Papy';
        gameMode = null;
        // Close modal if open
        hideModal();
        // Reinitialize board/UI but do not auto-start a game; user will choose mode and starter again
        initBoard();
        selectedPiece = null;
        validMoves = [];
        mustCapture = false;
        continuousCapture = false;
        piecesThatCouldCapture = [];
        currentPlayer = 'red';
        renderBoard();
        updateStatus('S√©lectionnez un mode de jeu');
    }

    // --- Modal and button wiring ---
    const btnPlayTogether = document.getElementById('btn-play-together');
    const btnPlaySolo = document.getElementById('btn-play-solo');
    const modal = document.getElementById('choiceModal');
    const modalTitle = document.getElementById('modalTitle');
    let choosePapy = document.getElementById('choosePapy');
    let chooseMamie = document.getElementById('chooseMamie');

    let modalContext = null; // 'pvp' or 'bot'
    let persistedHumanLabel = 'Papy';

    btnPlayTogether.addEventListener('click', () => {
        modalContext = 'pvp';
        // ensure previous starter isn't reused so modal always prompts
        startGame.startingPlayer = undefined;
        persistedStarter = undefined;
        // Show normal Papy/Mamie choice to decide who starts
        // Ensure the modal buttons run the first-step handlers
        choosePapy.onclick = firstStepPapy;
        chooseMamie.onclick = firstStepMamie;
        choosePapy.textContent = 'Papy (Rouge)';
        chooseMamie.textContent = 'Mamie (Noir)';
        modalTitle.textContent = 'Qui commence ?';
        showModal();
    });

    btnPlaySolo.addEventListener('click', () => {
        modalContext = 'bot';
        // ensure previous starter isn't reused so modal always prompts
        startGame.startingPlayer = undefined;
        persistedStarter = undefined;
        // In bot mode, first choose which label represents the human; human will always be RED.
        // Ensure the modal buttons run the first-step handlers
        choosePapy.onclick = firstStepPapy;
        chooseMamie.onclick = firstStepMamie;
        choosePapy.textContent = 'Papy (Rouge)';
        chooseMamie.textContent = 'Mamie (Rouge)';
        modalTitle.textContent = 'Qui jouera contre le Robot Erwann ?';
        showModal();
    });

    // Define first-step handlers for the modal buttons (Papy / Mamie)
    function firstStepPapy() {
        if (modalContext === 'pvp') {
            // Papy starts as RED
            persistedHumanColor = 'red';
            startGame.startingPlayer = 'red';
            persistedStarter = 'red';
            hideModal();
            startGame('pvp');
            return;
        }

        // Bot mode: human label = Papy, human color = RED
        persistedHumanLabel = 'Papy';
        persistedHumanColor = 'red';
        // Next ask who starts (player or bot)
        showStarterModal();
    }

    function firstStepMamie() {
        if (modalContext === 'pvp') {
            // Mamie starts as BLACK
            persistedHumanColor = 'black';
            startGame.startingPlayer = 'black';
            persistedStarter = 'black';
            hideModal();
            startGame('pvp');
            return;
        }

        // Bot mode: human label = Mamie, but human color is still RED (user wants to play as Mamie but keep RED)
        persistedHumanLabel = 'Mamie';
        persistedHumanColor = 'red';
        // Next ask who starts (player or bot)
        showStarterModal();
    }

    // Attach these as the default first-step handlers when the modal is shown by Play buttons
    // (btnPlayTogether and btnPlaySolo set choosePapy.onclick/chooseMamie.onclick below)

    function showStarterModal() {
        modalTitle.textContent = 'Qui commence ?';
        // Configure buttons for the starter choice step (player vs bot)
        choosePapy.textContent = `Le joueur (${persistedHumanLabel})`;
        chooseMamie.textContent = 'Le Robot Erwann';

        // Replace onclick handlers for this step
        choosePapy.onclick = () => {
            hideModal();
            startGame.startingPlayer = 'red';
            persistedStarter = 'red';
            startGame('bot');
        };

        chooseMamie.onclick = () => {
            hideModal();
            startGame.startingPlayer = 'black';
            persistedStarter = 'black';
            startGame('bot');
        };
    }

    function showModal() {
        modal.style.display = 'flex';
    }

    function hideModal() {
        modal.style.display = 'none';
    }

    initBoard();
    renderBoard();
</script>
</body>
</html>